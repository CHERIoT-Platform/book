\chapter[label=language_extensions]{C/C++ extensions for CHERIoT}

The CHERIoT platform adds a small number of C/C++ annotations to support the compartment model.

\section[label=exporting_functions]{Exposing compartment entry points}

Compartments are discussed in detail in \ref{compartments}.
A compartment can expose functions as entry points via a simple attribute.

The \c{cheri_compartment({name\})} attribute specifies the name of the compartment that defines a function.
This is used in concert with the \flag{-cheri-compartment=} compiler flag.
This allows the compiler to know whether a particular function (which may be in another compilation unit) is defined in the same compartment as the current compilation unit, allowing direct calls for functions in the same compilation unit and cross-compartment calls for other cases.

This can be used on either definitions or declarations but is most commonly used on declarations.

If a function is defined while compiling a compilation unit belonging to a different compartment then the compiler will raise an error.
In CHERIoT RTOS, this attribute is always used via the \c{__cheri_compartment({name\})} macro.
This makes it possible to simply use \c{#define __cheri_compartment(x)} when compiling for other platforms.

Most of the time, you will not need to worry about the compiler flags directly.
The \command{xmake} provided by CHERIoT RTOS will set the compiler flags for you automatically.
\ref{lst:simpleexport} shows the prototype of a trivial function that increments an integer that is private to a compartment.

\codelisting[filename=examples/compartment_annotation/interface.h,marker=compartment_export,label=lst:simpleexport,caption="Exporting a function for use by other compartments from a header."]{}

The body of this function is then shown in \ref{lst:incrementfn}.
Note that this does not require the attribute, it is inherited from the prototype.
If you forget to include the header, you will see a linker error about a missing symbol.
\fixme{I thought we now had a better linker error but I can't reproduce it.}

\codelisting[filename=examples/compartment_annotation/compartment.cc,marker=increment,label=lst:incrementfn,caption="The body of a function that is exposed for cross-compartment calls."]{}

The build system specifies the \flag{-cheri-compartment=} flag based on the \lua{compartment} target definition in the \file{xmake.lua}.
\ref{lst:xmakecompartment} shows this for the simple example compartment.

\lualisting[filename=examples/compartment_annotation/xmake.lua,marker=compartment,label=lst:xmakecompartment,caption="Build system code for defining a compartment."]{}

If you get the compartment name wrong, the compiler will generate an error.
For example, if you change the compartment name in this example to \c{"hello"} in the source code, you will see the following:

\begin{console}
error: entry.cc:15:35: error: CHERI compartment entry declared for compartment 'hello' but implemented in 'entry' (provided with -cheri-compartment=)
   15 | void __cheri_compartment("hello") entry()
      |                                   ^
1 error generated.
\end{console}

\section[label=cheri_callback]{Passing callbacks to other compartments.}

The \c{cheri_ccallback} attribute specifies a function that can be used as an entry point by compartments that are passed a function pointer to it.
This attribute must also be used on the type of function pointers that hold cross-compartment invocations.
Any time the address of such a function is taken, the result will be a sealed capability that can be used to invoke the compartment and call this function.

\begin{note}
	The compiler does not know, when calling a callback, whether it points to the current compartment.
	As such, calling a CHERI callback function will \textem{always} be a cross-compartment call, even if the target is in the current compartment.
\end{note}

This attribute can also be used via the \c{__cheri_callback} macro, which allows it to be defined away when targeting other platforms.

\ref{lst:callbackexport} shows both how to declare a \c{typedef} for a function pointer type that can be used for cross-compartment callbacks and how to expose a function that takes one.
This is a simple function that will increment a private counter and invoke the callback.

\codelisting[filename=examples/compartment_annotation/interface.h,marker=compartment_export_callback,label=lst:callbackexport,caption="Exposing a function that takes a cross-compartment callback for use by other compartments."]{}

The implementation of this function (\ref{lst:monotoniccallbackfn}) calls it just as it would call any other function pointer.
The difference is dealt with entirely by the compiler.
For a normal call, the compiler will emit a simple jump-and-link to the address, whereas in this case it will invoke the switcher (see \ref{_changing_trust_domain_with_the_switcher}) with the callback as an extra argument.

Every function that's exposed for cross-compartment invocation has an entry in the compartment's \keyword{export table}, containing the metadata that the switcher will use.
Every function that is directly called by another compartment will then have an entry in the calling compartment's \keyword{import table} that the loader will initialise with a sealed capability to the export table entry.
Callback functions work in a similar way, except that the import-table entry is for the compartment that exposes the callback.

When you take the address of a callback function, the compiler simply inserts a load of the import-table entry, giving exactly the same kind of sealed capability that you would use for direct cross-compartment calls.
At the call site, the only difference between a direct cross-compartment call and a callback is that the former will contain the load from the import table, whereas the latter will simply move the callback into the register that is used to pass the callee to the switcher.

\codelisting[filename=examples/compartment_annotation/compartment.cc,marker=monotonic,label=lst:monotoniccallbackfn,caption="The body of a function that invokes a cross-compartment callback."]{}

The callback is then declared just like any other function, but with the correct attribute, as shown in \ref{lst:declaresimplecallback}.

\begin{note}
	The function attributes can be provided either before the start of the function or before the function name (after the return type).
	In some cases, the latter can avoid ambiguity (the attribute definitely applies to the function, not to the return type), but both are equivalent the rest of the time.
\end{note}

\codelisting[filename=examples/compartment_annotation/entry.cc,marker=callback,label=lst:declaresimplecallback,caption="A function that can be invoked as a cross-compartment callback."]{}

The callback function is passed just like any other function pointer, as shown in \ref{lst:passsimplecallback}.
Note that the two ways of taking the address of a function in C/C++ (\c{callback} and \c{&callback}) are equivalent.
Both work, some people prefer the former because it is more concise, others prefer the latter because it is a visual marker that a pointer is being constructed.

\codelisting[filename=examples/compartment_annotation/entry.cc,marker=compartment_call,label=lst:passsimplecallback,caption="A function that can be invoked as a cross-compartment callback."]{}

When you run this example 

\section{Exposing library entry points}

Libraries are discussed in detail in \ref{compartments}.
Like compartments, they can export functions, via a simple annotation.
Unlike compartments, they are simply a mechanism for code sharing, not a security boundary.
Libraries do not have mutable globals and each call to a library is assumed to have access to everything in the caller.
Libraries are intended to provide almost the same abstraction as if you'd copied and pasted code into each compartment that calls them, though without the accompanying code duplication.

The \c{cheri_libcall} attribute specifies that this function is provided by a library (shared between compartments).
This attribute is implicit for all compiler built-in functions, including \c{memcpy} and similar freestanding C environment functions.
As with \c{cheri_compartment()}, this may be used on both definitions and declarations.

Unlike the compartment annotation, the library annotation does not specify the library that provides the function (though you can validate this later with the auditing tooling, as described in \ref{cheriot-audit}.
This allows library functions to be moved between libraries easily, a refactoring that does not affect most of the security model.
For example, the RTOS used to provide a library that implemented all of the helpers for atomic operations.
This was later split into separate libraries for different sized objects, allowing code to link only the atomic operations for types that it uses.

This attribute can also be used via the \c{__cheri_libcall} macro, which allows it to be defined away when targeting other platforms.
This is how it is used in \ref{lst:declarelibfn}, which declares a simple library function.

\codelisting[filename=examples/library_annotation/interface.h,marker=library_export,label=lst:declarelibfn,caption="A declaration of a library function"]{}

As with the compartment annotations, these don't need to be placed on both the prototype and the declaration.
\ref{lst:definelibfn} shows the definition, which omits the attribute.

\codelisting[filename=examples/library_annotation/library.cc,marker=library_implementation,label=lst:definelibfn,caption="A definition of a library function"]{}

Both the library function and the call site, shown in \ref{lst:calllibfn} use the CHERIoT RTOS debugging APIs that are described in detail in \ref{debug}.
These allow you to, among other things, pretty-print capabilities.
These use a compiler builtin to get the capability to the stack and print it.

\codelisting[filename=examples/library_annotation/entry.cc,marker=entry,label=lst:calllibfn,caption="Calling a simple library function."]{}

When you run this example, you should see the stack capability printed twice, once by the entry compartment and once by the library.
The library is called from the compartment and so you should see the stack pointer move, but the bounds will remain the same.
When you run it, you should see something like this:

\begin{console}
Entry compartment: Stack pointer: 0x80000af0 (v:1 0x80000720-0x80000b20 l:0x400 o:0x0 p: - RWcgml -- ---)
Library: Stack pointer: 0x80000ad0 (v:1 0x80000720-0x80000b20 l:0x400 o:0x0 p: - RWcgml -- ---)
\end{console}

The bounds (\tty{0x80000720-0x80000b20}) remain constant across the call.
This means that malicious code in the library could inspect or modify everything on the caller's stack.
In contrast, if you try the same thing in a compartment, you will see this stack truncated.

Try modifying this example to place the function in a compartment instead of a library.
Don't forget to modify the \file{xmake.lua} file to change the \lua{library} target to \lua{compartment}.

\section{Interrupt state control}

The \c{cheri_interrupt_state} attribute (commonly used as a C++11 / C23 attribute spelled \c{cheri::interrupt_state}) is applied to functions and takes an argument that is one of the following:
\fixme{Should probably rename this cheriot in the compiler}

\begin{description}
	\item[tag=enabled]{Interrupts are enabled when calling this function.}
	\item[tag=disabled]{Interrupts are disabled when calling this function.}
	\item[tag=inherit]{ The interrupt state is unchanged (inherited from the caller) when invoking the function.}
\end{description}

For most functions, \c{inherit} is the default.
For cross-compartment calls, \c{enabled} is the default and \c{inherit} is not permitted.

The compiler may not inline functions at call sites that would change the interrupt state and will always call them via a sentry capability set up by the loader.
This makes it possible to statically reason about interrupt state in lexical scopes.

\begin{caution}
If a compartment is able to provide arbitrary interrupt-disabled functions, that compartment is in the TCB for availability.
It is a good idea to move interrupts-disabled code into library functions where the contents of the library can be audited and the exact binary for the interrupt-disabled function can be part of a \keyword{software bill of materials} (SBOM), which can then allow you to reason about the whole system's availability guarantees.
\end{caution}

If you need to wrap a few statements to run with interrupts disabled, you can use the convenience helper \cxx{CHERI::with_interrupts_disabled}.
This is annotated with the attribute that disables interrupts and invokes the passed lambda.
This maintains the structured-programming discipline for code running with interrupts disabled: it is coupled to a lexical scope.

\functiondoc{with_interrupts_disabled}

You need to be very careful using this attribute.
\ref{lst:lowpriorityinterruptsdisabled} shows a very simple example of how disabling interrupts can have adverse effects.
The \cxx{spin_for_ticks} function in this example will simply spin for the requested number of ticks, reading the cycle counter until enough time has elapsed.
This is called by a thread entry-point function that runs with low priority, with increasing tick counts.

The \c{rdcycle64} function reads the cycle timer.
The \c{thread_sleep} call is sleeping for a single scheduler tick.
This function and the meaning of a scheduler tick are explained in more detail in \ref{threads}.
For now, assume that the thread is attempting to sleep for the number of cycles shown by the \c{printf} call at the start, outside of the loop.

\codelisting[filename=examples/interrupts_disabled/interrupts.cc,marker=low,label=lst:lowpriorityinterruptsdisabled,caption="A low-priority thread that uses an interrupts-disabled function to consume CPU."]{}

The other thread in this program is shown in \ref{lst:highpriorityinterruptsdisabled}.
This runs with high priority and so will always preempt the low-priority thread when it is able to, but disabling interrupts means that preemption is impossible.
Timer interrupts do not fire and so the scheduler cannot interrupt the function.

\codelisting[filename=examples/interrupts_disabled/interrupts.cc,marker=high,label=lst:highpriorityinterruptsdisabled,caption="A high-priority thread that is starved but an interrupts-disabled function called from a low-priority thread."]{}

When you run this, you will see that the actual time spent sleeping increases each iteration:

\begin{console}
One tick is 10000 cycles
low-priority thread running
Cycles elapsed with high-priority thread yielding: 23461
low-priority thread running
Cycles elapsed with high-priority thread yielding: 33450
low-priority thread running
Cycles elapsed with high-priority thread yielding: 43449
low-priority thread running
Cycles elapsed with high-priority thread yielding: 53448
\end{console}

The low-priority thread is allowed to start running when the high-priority thread yields but then prevents any other thread in the system from running.
If you did anything like this in a realtime system, this would guarantee that you would would miss your realtime deadlines.

The key problem here is that the interrupts-disabled function has an unbounded run time.
It will consume the CPU for a data-dependent amount of time with no practical upper bound.
When you are building realtime systems, even very soft realtime systems, you must ensure that the worst-case execution time for responding to events is bounded.

\section{Importing MMIO access}

The \c{MMIO_CAPABILITY({type\}, {name\})} macro is used to access memory-mapped I/O devices.
These are specified in the board definition file by the build system.
The \c{DEVICE_EXISTS({name\})} macro can be used to detect whether the current target provides a device with the specified name.

The \c{type} parameter is the type used to represent the MMIO region.
The macro evaluates to a \c{volatile {type\} *}, so \c{MMIO_CAPABILITY(struct UART, uart)} will provide a \c{volatile struct UART *} pointing (and bounded) to the device that the board definition exposes as \c{uart}.

\section{Manipulating capabilities with C builtins}

The compiler provides a set of built-in functions for manipulating capabilities.
These are typically of the form \c{__builtin_cheri_{noun\}_{verb\}}.
You can read all of the fields of a CHERI capability with \c{get} as the verb and the following nouns:

\begin{description}
	\item[tag=address]{The current address that's used when the capability is used a pointer.}
	\item[tag=base]{The lowest address that this authorises access to.}
	\item[tag=top]{The address immediately after the end of the range that this authorises access to.}
	\item[tag=length]{The distance between the base and the top.}
	\item[tag=perms]{The architectural permissions that this capability holds.}
	\item[tag=sealed]{Is this a sealed capability?}
	\item[tag=tag]{Is this a valid capability?}
	\item[tag=type]{The type of this capability (zero means unsealed).}
\end{description}

The verbs vary because they express the \keyword{guarded manipulation} guarantees for CHERI capabilities.
You can't, for example, arbitrarily set the permissions on a capability, you can only remove permissions.
Capabilities can be modified with the nouns and verbs listed in \ref{tbl:cap_modification_builtins}.

\begin{table} % W: -> unmatched "\begin{table}"
	\begin[cols="16%fw 20%fw 64%fw"]{tabular} % W: Use either `` or '' as an alternative to `"'. (18)
		\tr{ \th{Noun} \th{Modification verb} \th{Operation}} % W: possible unwanted space at "{"
		\tr{\td{\c{address}} \td{\c{set}}             \td{Set the address for the capability.}}
		\tr{\td{\c{bounds}}  \td{\c{set}}             \td{Sets the base at or below the current address and the length at or above the requested length, as closely as possible to give a valid capability}}
		\tr{\td{\c{bounds}}  \td{\c{set_exact}}       \td{Sets the base to the current address and the length to the requested length or returns an untagged capability if the result is not representable.}}
		\tr{\td{\c{perms}}   \td{\c{and}}             \td{Clears all permissions except those provided as the argument.}}
		\tr{\td{\c{tag}}     \td{\c{clear}}           \td{Invalidates the capability but preserves all other fields.}}
	\end{tabular} % W: <- unmatched "\end{tabular}"
	\caption[label=tbl:cap_modification_builtins]{CHERI capability manipulation builtin functions}
\end{table} % W: <- unmatched "\end{table}"


Setting the object type is more complex.
This is done with \c{__builtin_cheri_seal}, which takes an authorising capability (something with the permit-seal permission) as the second argument and sets the object type of the result to the address of the sealing capability.
Conversely, \c{__builtin_cheri_unseal} uses a capability with the permit-unseal capability and address matching the object type to restore the original unsealed value.

Most of the time, C code will avoid using the builtins directly and instead use the wrappers defined in \file{cheri-builtins.h}.
This file contains a set of macros that wrap the builtins to remove the \c{__builtin_} prefix.

\begin{note}
	Although most of the macros in \file{cheri-builtins.h} match the names of the underlying builtins, the permissions ones follow the CHERIoT RTOS coding convention of avoiding abbreviations and so use \c{permissions} instead of \c{perms}.
	The predicates prefix the operation with \c{_is} so \c{__builtin_cheri_equal_exact} becomes \c{cheri_is_equal_exact}.
\end{note}

You can see how to use most of the introspection builtins via their macro wrappers in \ref{lst:prettyprintcapc}.
This prints a capability, showing its address, tag (valid) bit, length, bounds, and permissions.
The permissions are expanded as the letters from the tables in \ref{permissions}.
The builtins are thing wrappers around the instructions, which represent the permissions as a bitmask.
Individual bits must be extracted by a bitwise and operation.

\codelisting[filename=examples/manipulate_capabilities_c/example.c,marker=print_capability,label=lst:prettyprintcapc,caption="Pretty printing a capability using the C builtin wrappers."]{}

\ref{lst:capmanipc} uses this function to print both some initial capabilities from heap and stack memory and then manipulates them.
First, it explicitly sets the bounds of the heap capability to 23 bytes, then removes all permissions except load.

\codelisting[filename=examples/manipulate_capabilities_c/example.c,marker=capability_manipulation,label=lst:capmanipc,caption="Manipulating capabilities using the C builtin wrappers."]{}

When you run this example, you should see something like this (the exact addresses may vary):

\begin{console}
0x80000ae1 (valid:1 length: 0x17 0x80000ae1-0x80000af8 otype:0 permissions: - RWcgml -- -)
0x80006710 (valid:1 length: 0x18 0x80006710-0x80006728 otype:0 permissions: G RWcgm- -- -)
0x80006710 (valid:1 length: 0x17 0x80006710-0x80006727 otype:0 permissions: G RWcgm- -- -)
0x80006710 (valid:1 length: 0x17 0x80006710-0x80006727 otype:0 permissions: - R----- -- -)
0x80006710 (valid:1 length: 0x18 0x80006710-0x80006728 otype:0 permissions: G RWcgm- -- -)
\end{console}

First, note the difference between the permissions on the stack and heap allocation.
The heap allocation has global permission: it may be stored anywhere.
The stack allocation lacks global, but has store-local permission, which allows it to be used to store other capabilities that lack the global permission.
This ensures that stack pointers can be stored only on the stack.

The bounds on the original heap allocation are rounded up to a multiple of the heap's allocation granule size.
The CHERIoT allocator allocates 8-byte chunks, so this is rounded up to 24 (0x18) bytes.
For a capability this small, CHERIoT can precisely represent the desired size and so the bounds setting operation succeeds and you can derive a capability with the precise bounds that we requested.
Next, this removes all permissions except load.
This pointer now provides a read-only view of the data, which cannot be stored anywhere except on the stack and which cannot be used to load capabilities.

Finally, this example prints the heap allocation again to remind you that these permissions and bounds apply to the \textem{pointer} and not to the \textem{object}.
We have not removed permissions from an object, we have created a pointer that has fewer permissions to that object.
There is no limit to the number of pointers that can exist to a single object.

\section{Comparing capabilities with C builtins}

By default, the C/C++ \c{==} operator on capabilities compares only the address.

\begin{note}
	This is subject to change in a future revision of CHERI C.
	It makes porting some existing code easier, but breaks the substitution principle (if \c{a == b}, you would expect to be able to use \c{b} or \c{a} interchangeably).
\end{note}

You can compare capabilities for exact equality with the \c{__builtin_cheri_equal_exact}, or the \c{cheri_is_equal_exact} macro that wraps the builtin.
This returns true if the two capabilities that are passed to it are identical, false otherwise.
Exact equality means that the address, bounds, permissions, object type, and tag are all identical.
It is, effectively, a bitwise comparison of all of the bits in the two capabilities, including the tag bits.

You can see the difference between the two in \ref{lst:capequal}.
This creates a capability with a small offset into an on-stack buffer and then restricts the bounds and removes permissions from it, then compares them for equality using both the \c{==} operator and the \c{cheri_is_equal_exact} macro.

\codelisting[filename=examples/compare_capabilities/example.c,marker=capability_equality,label=lst:capequal,caption="Comparing two capabilities for equality."]{}

When you run this example, you should see output that looks something like this:

\begin{console}
0x80000ae5 (valid:1 length: 0x17 0x80000ae1-0x80000af8 otype:0 permissions: - RWcgml -- -)
0x80000ae5 (valid:1 length: 0x4 0x80000ae5-0x80000ae9 otype:0 permissions: - RWcgml -- -)
Equal? 1
Exactly equal? 0
0x80000ae5 (valid:1 length: 0x4 0x80000ae5-0x80000ae9 otype:0 permissions: - R----- -- -)
Equal? 1
Exactly equal? 0
0x80000ae5 (valid:0 length: 0x4 0x80000ae5-0x80000ae9 otype:0 permissions: - R----- -- -)
Equal? 1
Exactly equal? 0
\end{console}

First it shows the original capability, which grants complete access to a stack allocation and has its address four bytes offset into the object.
Then the bounded capability, which has the same address and permissions, but different bounds.
These compare equal with address-based comparison but not exactly equal.

Next it removes permissions from the derived capability and compares these.
Again, the difference in permissions is not reflected in the address-based equality but is in the exact equality.

The final case is the most interesting and the one where this can be the most confusing.
The last pointer constructed in this example is not a capability.
This is constructed by clearing the tag, which is the bit that indicates that the capability-sized word is, in fact, a capability.
Losing the tag bit means that this is not a capability at all, merely 64 bits of data that happen to be loaded into a capability register.
With the C equality operator, this \textem{still} compares equal to any of the other capabilities, but the exact-equality comparison fails.

Ordered comparison, using operators such as less-than or greater-than, always operate with the address.
There is no total ordering over capabilities.
Two capabilities with different bounds or different permissions but the same address will return false when compared with either \c{<} or \c{>}.

This is fine according to a strict representation of the C abstract machine because comparing two pointers to different objects is undefined behaviour.
It can be confusing but, unfortunately, there is no good alternative.
Comparison of pointers is commonly used for keying in collections.
For example, the C++ \cxx{std::map} class uses the ordered comparison operators for building a tree and relies on it working correctly for keys that are pointers.
Ideally, these would explicitly operate over the address, but that would require invasive modifications when porting to CHERI platforms.

You can see the case that can make this confusing in \ref{lst:capordering}.
This compares two capabilities using the ordered operators and then exact equality.

\codelisting[filename=examples/compare_capabilities/example.c,marker=capability_ordering,label=lst:capordering,caption="Trying to construct an ordering over two capabilities."]{}

When you run this example, it will print:

\begin{console}
bounded is not greater than, less than, nor equal to, offset
\end{console}

This highlights that, within the C abstract machine, there is no good choice for what \c{==} should do on capabilities.
In the current version, it breaks the substitution principle: you cannot use \c{a} and \c{b} interchangeably if \c{a == b}.
In the alternative version, existing code that does \c{a < b} and \c{a > b} and assumes that \c{a == b} holds if both ordered comparisons fail would now be incorrect.

In general, in new code, you should avoid comparing pointers for anything other than exact equality, unless you are certain that they have the same base and bounds.
Instead, be explicit about exactly what you are testing.
Do you care if the permissions are different?
Do you care about the bounds?
Do you care if the value is tagged?
Or do you just want to care about the address?
In each case, you should explicitly compare the components of the capability that you care about.

You can also compare capabilities for subset relationships with \c{__builtin_cheri_subset_test}.
This returns true if the second argument is a subset of the first.
A capability is a subset of another if every right that it conveys is held by the other.
This means the bounds of the subset capability must be smaller than or equal to the superset and all permissions held by the subset must be held by the superset.

You can see this for the capabilities that we've been looking at in \ref{lst:captestsubset}.

\codelisting[filename=examples/compare_capabilities/example.c,marker=capability_subset,label=lst:captestsubset,caption="Subset relationships over two capabilities."]{}

When you run this, the output is:

\begin{console}
bounded ⊂ offset? 1
restricted ⊂ bounded? 1
untagged ⊂ restricted? 0
offset ⊂ bounded? 0
\end{console}

Most of these lines should not be a surprise.
The bounded capability is a subset of the original, it was created by subsetting the bounds.
The capability that was created by subsetting the rights on the bounded version is, in turn a subset of the bounded version.
Finally, the original is not a subset of the bounded version.

The surprising entry might be that the untagged capability is not a subset of the original.
In a set-theoretic sense, this would be incorrect: The empty set is a subset of any other set.
In practice, this degenerate case is not a useful.

The test-subset operation gives a unidirectional substitution property (i.e. any operation that is safe to do with the subset is safe to do with the superset) but this is not usually something that you care about.
The test is most useful for telling if one capability is \textem{derived from} another (or, at least, could have a derivation path from a specific common root).
For example, we can tell that (ignoring stack lifetime errors) \c{bounded} and \c{restricted} are both derived from the original stack allocation.
It happens that, in this specific case, \c{unbounded} was derived from the same stack allocation but the lack of a tag bit means that there are no \keyword{provenance} guarantees.
For untagged values, we can make no claims about whether they were derived from any other capabilities.

This is useful to check if a particular pointer that you've been given is derived from something that you already own.
The claims mechanisms (described in \ref{heap_claim}) uses this, for example, to allow threads to keep an object alive if you hold a pointer derived from the original object pointer.
The temporal-safety properties of CHERIoT ensure that any dangling pointer to a heap object will be untagged and so any valid (tagged) pointer that is a subset of a heap allocation must be derived from the return from the original call to \c{malloc} or some similar function.

\section{Sizing allocations}

CHERI capabilities cannot represent arbitrary bases and bounds.
The original CHERI prototypes, with a 64-bit address, encoded a 64-bit top address and a 64-bit base.
This made capabilities 256 bits in total (four times the address size), which was not feasible for production implementations (though having lots of space was very useful for prototyping).
Fortunately, there is a lot of redundancy between these three values.
Generally, for any allocation, the high bits of the base, top, and some in-bounds address will all be the same.

CHERI systems since around 2016 have used compressed bounds encodings that take advantage of this redundancy.
Rather than storing a complete address for the top and bottom, they store a floating-point value that is the distance from the address to the top and from the address to the base.
The exponent bits are shared between the two.
This means that, the larger the bounds, the more strongly aligned the base and bounds must be.

\begin{note}
The current CHERIoT encoding gives byte-granularity bounds for objects up to 511 bytes, then requires one more bit of alignment for each bit needed to represent the size, up to 8 MiB.
Capabilities larger than 8 MiB must be aligned on an 8 MiB boundary for their base and top.
This is ample for small embedded systems where most compartments or heap objects are expected to be under tens of KiBs.

This is a slightly simplified version of the original CHERI scheme, which simplifies critical-path lengths on short pipelines.
Future versions of CHERIoT are likely to support slightly more expressive formats on longer pipelines.
Other CHERI systems make different trade offs.
\end{note}


Calculating the length can be non-trivial and can vary across CHERI systems.
The compiler provides two builtins that help.

The first, \c{__builtin_cheri_round_representable_length}, returns the smallest length that is larger than (or equal to) the requested length and can be accurately represented.
The compressed bounds encoding requires both the top and base to be aligned on the same amount and so there's a corresponding mask that needs to be used for alignment.
The \c{__builtin_cheri_representable_alignment_mask} builtin returns the mask that can be applied to the base and top addresses to align them.

\ref{lst:capalignmasks} shows how to use these builtins via their wrappers to find the smallest representable size for a requested size.

\codelisting[filename=examples/bounds_lengths/example.c,marker=representable_range,label=lst:capalignmasks,caption="Rounding up sizes for representable allocations."]{}

The allocator is using these internally when it determines the size to provide for a request and the alignment that it needs to find.
When you run it, you may see something like this.

\begin{console}
Smallest representable size of 160000-byte allocation: 160256 (0x27200). Alignment mask: 0xfffffe00
0x80006800 (valid:1 length: 0x27200 0x80006800-0x8002da00 otype:0 permissions: G RWcgm- -- -)
\end{console}

The requested size needs to be rounded up to 160,256 bytes.
The hex representation makes it easier to see the alignment is 0x200, or 512 in decimal.
The top and bottom of an allocation that can accurately represent the requested size must be 512-byte aligned.
The alignment mask is simply another way of representing this, it is nine zeroes in the low bits and ones in all of the high bits.

When the allocator returns a value for this requested size, the length is rounded up as you'd expect.
If you bitwise and the base and top with the alignment mask, you will see no change.
Both are, in this specific case, slightly more strongly aligned than required, most likely because this is the first \c{malloc} call in the program and so these are as strongly aligned as the heap base.
You can test that the alignment is adequate by doing a bitwise and (C operator: \c{&}) of the base or top with the alignment mask.
This should leave the value unmodified.

\section[label=cheri_capability_cpp]{Manipulating capabilities with \cxx{CHERI::Capability}}

The raw C builtins can be somewhat verbose.
CHERIoT RTOS provides a \cxx{CHERI::Capability} class in \file{cheri.hh} to simplify inspecting and manipulating CHERI capabilities.

These provide methods that are modelled to allow you to pretend that they give direct access to the fields of the capability.
The \file{manipulate_capabilities_cxx} example shows how to do the same things as the \file{manipulate_capabilities_c} example, this time with the C++ APIs.
First, \ref{lst:prettyprintcapcxx} reimplements the \cxx{print_capability} function using \cxx{CHERI::Capability}.
This is slightly more verbose because it's printing with the \c{printf} function, which is a C variadic and so cannot take the result of \cxx{ptr.address()}, which is a proxy that allows you to manipulate the address.

\codelisting[filename=examples/manipulate_capabilities_cxx/example.cc,marker=print_capability,label=lst:prettyprintcapcxx,caption="Pretty printing a capability using the C++ APIs."]{}

\begin{note}
The \cxx{using P = CHERI::Permission} is not good style.
It is done here so that the example code fits in a narrow page.
In normal code, a mode descriptive name would be better.
\end{note}

Note the \cxx{CHERI::PermissionSet} class here.
This is a (\cxx{constexpr}) class that encapsulates a CHERI permission set.
The C version of this exposed the permissions in their raw form as a word where each bit represented a permission.
The C++ version uses a rich type, with methods for subsetting.
This can be used as a template parameter and can be used in static assertions for compile-time validation of derivation chains.
The loader makes extensive use of this class to ensure correctness, with compile-time checks that operations on permission-set objects are valid.

This part of the example uses the \cxx{contains()} method to query whether a specific permission is present.
This is strongly typed, it takes a \cxx{CHERI::Permission}, not an arbitrary integer.
It is also a variadic template function: you can pass it multiple permissions and it will return true if and only if the permission set has all of them.

Next, \ref{lst:capmanipcxx} does the same set of manipulations as \ref{lst:capmanipc}.
This uses a \cxx{CHERI::Capability<void>} rather than a \c{void*} to hold the pointers.

\codelisting[filename=examples/manipulate_capabilities_cxx/example.cc,marker=capability_manipulation,label=lst:capmanipcxx,caption="Manipulating capabilities using the C++ APIs."]{}

The \cxx{bounded.bounds() = 23} expression shows how the methods act like fields.
This is doing a set-bounds operation on the capability.
Similarly, the \cxx{&=} operation on the result of calling \cxx{permissions()} is an and-permissions operation.
This lets you operate on the permissions as a \cxx{CHERI::PermissionSet} directly.

The equality comparison for \cxx{CHERI::Capability} uses exact comparison, unlike raw C/C++ pointer comparison.
This is less confusing for new code (it respects the substitution principle) but users may be confused that \c{a == b} is true but \cxx{Capability{a\} == Capability{b\}} is false.
\ref{lst:capequalcxx} shows the various forms of comparison.

\codelisting[filename=examples/manipulate_capabilities_cxx/example.cc,marker=capability_equality,label=lst:capequalcxx,caption="Comparting capabilities using the C++ APIs."]{}

When you run this, you will see:

\begin{console}
heapBuffer == bounded? 0
heapBuffer == bounded (as raw pointers)? 1
heapBuffer == bounded (as address comparison)? 1
\end{console}

The last two comparisons are equivalent, but the third is more explicit.
If you want to compare two pointers for equality as address comparison, comparing their addresses makes the intent clear.

See \file{cheri.hh} for more details and for other convenience wrappers around the compiler builtins.

