\chapter{The RTOS Core}

The core of the RTOS is a set of privilege-separated components.
Each core component runs with some privileges that mean that it is (at least partially) in the trusted computing base (TCB) for other things.

\section{Starting the system with the loader}

The \keyword{loader} runs on system startup.
It reads the compartment headers and populates each compartment with the set of capabilities that it needs.
The loader exists so that the system can be started from a firmware image that does not embed capabilities.
This is a useful property even if a particular target has persistent storage (non-volatile RAM) that \textem{can} hold capabilities because it ensures that there is an on-device \keyword{pointer provenance} flow for the firmware.

If a device has non-volatile storage that holds tags, you will typically run the loader once at install time or on first boot of a new firmware image.
This ensures that the image contains only capabilities handed to it.
This, in turn, enables multi-stage boot where some functionality, such as attestation, secure key storage, and so on, are provided by a bootloader.
These abstractions can all be built from capabilities and so, unlike systems based on protection rings such as TrustZone, an arbitrary number can be nested.

If a compartment contains a global that is a pointer, initialised to point to another global, the loader will initialise pointer by deriving a capability from one out of the compartment's code or data capabilities.
Again, this enforces provenance properties, this time within a firmware image.
A malicious compartment may provide a relocation that points to a global outside its own memory, but the loader will attempt to derive the capability only from the compartment's initial \reg{pcc} (code) and \reg{cgp} (globals) regions and so will fail.

The loader must also provide all capabilities to compartments that allow them to communicate outside of their own private space.
This includes access to \keyword{memory-mapped I/O} (MMIO) regions, capabilities for pre-shared objects, for software-defined capabilities, and any capabilities for calling entry points exposed by other compartments or libraries.
The loader also creates the stacks and trusted stacks for each thread and creates their initial entry points.

The loader is the most privileged component in the system.
When a CHERIoT CPU boots, it will have a small set of \keyword{root capabilities} in registers.
These, between them, convey the full set of rights that can be granted by a capability.
Every capability in the running system is derived (often via many steps) from one of these.
As such, the loader is able to do anything.

\begin{note}
In a system with a multi-stage boot, the initial capabilities provided to the loader may be restricted, rather than the omnipotent set from CPU boot.
For example, an early loader may implement A/B booting by providing the RTOS loader with capabilities to only half of persistent memory.
\end{note}

The risk from the loader is mitigated by the fact that it does not run on untrusted data.
The loader operates only on the instructions generated by the linker and so it is possible to audit precisely what it will do (see \ref{cheriot-audit}).
It is also possible to validate this by running the loader in a simulator and capturing the precise memory state after it has run.

The loader enforces some of the guarantees in the initial state.
It is structured to be able to enforce some of these by construction.
For example, only stacks and trusted stacks (accessible only by the switcher, see \ref{_changing_trust_domain_with_the_switcher}) have store-local permission and these do not have global permission.
The scheduler derives these from a capability that has store-local but not global permissions and derives all other capabilities from one that has the store-local permission removed.

Before starting the system, the loader erases almost all of its code (leaving the stub that handles this erasure), its stack, and clears its registers.
The last bit of the loader's code becomes the idle thread (a wait-for-interrupt loop).
The loader's stack is used for the scheduler stack.
The memory that held loader's code is used for heap memory.

\section{Changing trust domain with the switcher}

The \keyword{switcher} is the most privileged component that runs after the system finishes booting.
It is responsible for transitions between threads (context switches) and between compartments (cross-compartment calls and returns).
The switcher is a very small amount of code—under 500 instructions—that is expected to be amenable to formal verification.

\begin{note}
Work is underway to formally verify the security properties of the switcher, but is still in early stages.
\end{note}

The switcher is the only component in a running CHERIoT system that has access-system-registers permission.
It uses this primarily to access a single reserved register that holds the \keyword{trusted stack}.
The trusted stack is a region of memory containing the register save area for context switches and a small frame for every cross-compartment call that allows safe return even if the callee has corrupted all state that it has access to.

Trusted stacks are set up by the loader.
The loader passes the scheduler (see \ref{_time_slicing_with_the_scheduler}) a sealed capability to each of these on initialisation.
The switcher holds the only permit-unseal capability for the type used to seal trusted stacks.

The context switch path spills all registers to the current trusted stack's save area and then invokes the scheduler, which returns a sealed capability to the next thread to run.
It then restores the register file from this thread and resumes.
If the scheduler returns an invalid capability (one not sealed with the correct type) then the switcher will raise a fault.
If the exception program counter capability on exception entry is within the switcher's capability, the switcher will terminate.

On the cross-compartment call path, the switcher is responsible for unsealing the capability that refers to the export table of the callee, clearing unused argument registers, pushing the information about the return to the trusted stack, subsetting the bounds of the stack, and zeroing the part of the stack passed to the callee.
On return, it zeroes the stack again, zeroes unused return registers, and restores the callee's state.

This means that the switcher is the only component that has access to either two threads', or two compartments', state at the same time.
As such, it is in the TCB for both compartment and thread isolation.
This risk is mitigated in several ways:

\begin{itemize}
	\item{The switcher is small.
		It contains a similar number of instructions to the amount of unverified code in seL4.}
	\item{The switcher is defensive.
		Most errors simply forcibly unwind to the previous trusted stack frame, so a compartment that attempts to attack the switcher exits to its caller.}
	\item{Like everything else in the system, it must follow the capability rules.
		Unlike an operating system running in a privileged mode on mainstream hardware, it does not get to opt out of memory protection, it is not able to access beyond the bounds of capabilities passed to it or access any memory to which it does not have an explicit capability.}
	\item{It is largely stateless, all state that it modifies is held in the trusted stack for the current thread.}
\end{itemize}

The switcher appears to the rest of the system as a library.
It can expose functions for inspecting or, in a small number of cases, modifying state.
These are defined in \file{switcher.h}.
For example, prior to performing a cross-compartment call, you may want to check that there is sufficient space on the trusted stack for the number of calls that it will need to make.
The \c{trusted_stack_has_space} function exposed by the switcher lets you query if the trusted stack has enough space for a specified number of cross-compartment calls.
The amount of (normal) stack space is directly visible in a compartment and so normal stack checks do not require the switcher to be involved.

\functiondoc{trusted_stack_has_space}

The switcher also implements the \c{thread_id_get} function, which provides a fast way for compartments to determine which thread they are currently running on.
This function is used in the implementation of priority-inheriting locks (see \ref{priority_inheritance}).
Implementing efficient priority-inheriting locks requires a fast mechanism for getting the current thread ID so that it can be stored in the lock.

\functiondoc{thread_id_get}

\section{Time slicing with the scheduler}

When the switcher receives an interrupt (including an explicit yield), it delegates the decision about what to run next to the \keyword{scheduler}.
The scheduler has direct access to the interrupt controller but, in most respects, is just another compartment.

The switcher also holds a capability to a small stack for use by the scheduler.
This is not quite a full thread.
It cannot make cross-compartment calls and is not independently schedulable.
When the switcher handles an interrupt, it invokes the scheduler's entry point on this stack.

The scheduler also exposes other entry points that can be invoked by cross-compartment calls.
These fulfil a role similar to system calls on other operating systems, for example waiting for external events or performing inter-thread communication.
The scheduler implements blocking operations by moving the current thread from a run queue to a sleep queue and then issuing a software interrupt instruction to branch to the switcher.
When the switcher then invokes the scheduler to make a scheduling decision, it will discover that the current thread is no longer runnable and pick another.
Once the thread becomes runnable again, the switcher resumes the thread from the point where it yielded, at which point it can return from the scheduler.

The scheduler is, by definition, in the TCB for availability.
It is the component that decides which threads run and which do not.
A bug in the scheduler (with or without an active attacker) can result in a thread failing to run.

It is not; however, in the TCB for confidentiality or integrity.
The scheduler has no mechanism to inspect the state of an interrupted thread.
When invoked explicitly, it is called with a normal cross-compartment call and so has no access to anything other than the arguments.

As with the switcher, the scheduler mitigates these risks by being small (though larger than the switcher).
It currently compiles to under 4 KiB of object code.
This small size is accomplished by providing only a small set of features that can be used as building blocks for other tasks.

For example, some embedded operating systems provide features such as message queues in their kernel.
In CHERIoT RTOS, these are provided by a separate library, which relies on the \keyword{futex} (see \ref{futex}) facility exposed by the scheduler to allow a producer to block when the queue is full and allow consumers to block when the queue is empty.

Futexes are the \textem{only} mechanism that the scheduler provides for blocking.
Interrupts are mapped to futexes and so threads wait for hardware or software events in exactly the same way.
This narrow interface and clear separation of concerns helps improve overall system security.

\section{Sharing memory from the allocator}

The final core component is the memory allocator, which provides the heap, which is used for all dynamic memory allocations.
This is discussed in detail in \ref{shared_heap}.
Sharing memory between compartments in CHERIoT requires nothing more than passing pointers (until you start to add availability requirements in the presence of mutual distrust).
This means that you can allocate objects (or complex object graphs) from a few bytes up to the entire memory of the system and share them with other compartments.

The allocator has access to the shadow bitmap and hardware revocation engine that enforce temporal safety for the heap, and is responsible for setting bounds on allocated memory.
It is therefore trusted for confidentiality and integrity of memory allocated from the heap.
If it incorrectly sets bounds, a compartment may gain access to memory belonging to another allocation.
If it incorrectly configures revocation state or reuses memory too early then a use-after-free bug may become exploitable.

The allocator is not able to bypass capability permissions, it simply holds a capability that spans the whole of heap memory.
As such, it is in the TCB only with respect to heap allocations.
It cannot access globals (or code), held in other compartments and so a compartment that does not use the heap does not need to trust the allocator.

The allocator also provides a rich set of mechanisms (described in \ref{shared_heap}) for two mutually distrusting compartments to ensure that memory is not deallocated at inconvenient times.

\section{Building firmware images}

CHERIoT RTOS uses the xmake build system.
Xmake is a build system implemented in Lua.
It was chosen because it is easy to add new kinds of build targets.

In a typical system that uses the compile-link process invented by Mary Allen Wilkes in the '60s, you compile source files to object code and then link object code to produce executables.
You may have an intermediate step that produces libraries.

The CHERIoT build process was designed to enable separate compilation and binary distribution of components.
Each source file is compiled either for use in a shared library or for use in a specific compartment.
This means that, when building compartments, the compiler invocation must know the compartment in which the object file will be used.

Next, compartments and libraries are linked.
This requires a special invocation of the linker that produces a relocatable object file with the correct structure.
At this point, the only exported symbols are those for exported functions and the only undefined symbols should be those for MMIO regions or exports from other compartments (see \ref{compartments} for more information).

\begin{note}
	The build system produces a \file{.library} or \file{.compartment} file for each shared library and each compartment.
\end{note}
In theory, these can be distributed as binaries and linked into a firmware image but this is not yet handled automatically by the build system.

The final link step produces a firmware image.
It also produces the JSON report that describes all cross-compartment interactions and is used for auditing.

Using the RTOS build system involves writing an \file{xmake.lua} file that describes the build.
This starts with some boilerplate:

\lualisting[filename=examples/hello_world/xmake.lua,marker=boilerplate,label=lst:xmakeboilerplate,caption="Build system code for importing the CHERIoT RTOS SDK"]{}

The \lua{set_project} call gives a name to the project.

Lines 7–9 import the RTOS SDK.
This first tries to use the \command{CHERIOT_SDK} environment variable and, if not, tries a relative file.
The \lua{sdkdir} variable should point to the location of the \file{sdk} directory from the RTOS repository.
Finally, line 11 selects the CHERIoT toolchain.
Ideally this line would not be needed, but \command{xmake}'s scoping rules require it to be provided here.

This boilerplate snipped will exist at the top of most \file{xmake.lua} files for CHERIoT.
Only the name of the project (and possibly the path to the SDK) will be different.

The SDK file provides rules for building the various kinds of CHERIoT components (compartments, libraries, and firmware) and also includes all of the libraries that are part of the RTOS.
These libraries include the core definitions for a freestanding C implementation (\c{memcpy} and friends), the atomic helpers for cores without atomic instructions, and the C runtime things that are called from compiler builtins.
See the \file{lib} directory in the SDK for a full list.

If you want your firmware built to support running on more than one CHERIoT implementation then you will typically want to make the board to target an option, as shown in \ref{lst:xmakeboardselect}.
This exposes a \flag{--board} option at the configure stage, we'll see how this is used later.

\lualisting[filename=examples/hello_world/xmake.lua,marker=board,label=lst:xmakeboardselect,caption="Build system code for allowing the board to be selected at configure time"]{}

You can set a default and we use \lua{"sail"} here for the simulator build from our Sail formal model of the ISA.
This refers to a board description file (see \ref{new_board}).
If you're usually targeting a particular hardware platform, setting the default here allows users to avoid specifying it manually on every build.
If you're \textem{always} targeting a particular hardware platform then you can avoid this entirely.

Next, you need to add any compartments and libraries that are specific to this firmware image.
In most cases, you can do this in just two lines, the first providing the name of the compartment and the second providing the list of files, as shown in \ref{lst:xmakecompartments}.
For this example, we'll have two compartments.
One is our entry point, the other is a function that we'll use as a simple example of a cross-compartment call.

\lualisting[filename=examples/hello_world/xmake.lua,marker=compartments,label=lst:xmakecompartments,caption="Build system code for building compartments"]{}

\begin{caution}
	The name of the compartment in the \file{xmake.lua} must match the name used for the exported function as described in \ref{exporting_functions}.
	If they do not match, the compiler will raise an error that a function is defined in the wrong compartment.
\end{caution}

This example is going to do a cross-compartment call and then print the result using \c{printf}, which is provided by the \c{stdio} library from the RTOS.
The cross-compartment call is exposed from \file{hello.h} as shown in \ref{lst:helloexport}.
The only difference between this and a normal C/C++ function prototype is the \c{__cheri_compartment} macro.
This is explained in detail in \ref{exporting_functions}.

\codelisting[filename=examples/hello_world/hello.h,marker=export,label=lst:helloexport,caption="Exporting a function for use by other compartments"]{}

The implementation of this function is trivial (see \ref{lst:toycompartmentcall}), it just returns \c{42}.
Note that, aside from the annotation from the function prototype, we don't need any changes to expose this for use from other compartments.
The same is true on the caller's side, as shown in \ref{lst:helloworldentry}.
Functions exported from a compartment are called just like any other C function.

\codelisting[filename=examples/hello_world/compartment.cc,marker=all,label=lst:toycompartmentcall,caption="A trivial implementation of an exported function"]{}

\codelisting[filename=examples/hello_world/hello.cc,marker=entry,label=lst:helloworldentry,caption="A simple compartment entry point that does a cross-compartment call"]{}

The \c{entry} function is also annotated as a function exported from a compartment.
This is because it's a \keyword{thread entry point}, a function that is called at the start of a thread.
In CHERIoT RTOS, threads are statically defined.
This is described in more detail in \ref{threads}.

Returning to the build system \ref{lst:xmakefirmware} shows how the \lua{firmware} block defines everything that's combined together to create a firmware image.
First, the \lua{add_deps} lines are defining the compartments and libraries that are linked.
The first two are libraries provided by the RTOS, implementing the core functions for a freestanding C environment and a minimal subset of \file{stdio.h} functions, respectively.
The next two are the compartments that we defined earlier.

Not all of the metadata that we set can be defined in the declarative syntax of \command{xmake} and so we have to implement a function using the \lua{on_load} hook to set the remaining properties.
The \lua{"board"} property is set from the option that we declared.
This is where, if you don't need to support multiple targets, you could directly specify the board that you wish to target.

\lualisting[filename=examples/hello_world/xmake.lua,marker=firmware,label=lst:xmakefirmware,caption="Build system code for linking the final firmware image"]{}

The \lua{"threads"} property is set to an array (as a Lua array literal) of thread descriptions.
Each thread must set five properties:

\begin{description}
	\item[tag=compartment]{ The compartment in which this thread starts.}
	\item[tag=entry_point]{ The name of the function for this thread's entry point.
		This must be a function that takes and returns \c{void}, exported from the compartment specified by the \lua{compartment} key.}
	\item[tag=priority]{ The priority of this thread.
		Higher numbers indicate higher priorities.}
	\item[tag=stack_size]{ The number of bytes of stack space that this thread has allocated.}
	\item[tag=trusted_stack_frames]{ The number of trusted stack frames.
		Each cross-compartment call pushes a new frame onto this stack and so this defines the maximum number of compartments call depth (including the entry point) for this thread.}
\end{description}
